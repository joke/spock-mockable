= `spock-mockable`

:icons: font

image:https://github.com/joke/spock-mockable/workflows/build/badge.svg?branch=main[]
image:https://badgen.net/github/license/joke/spock-mockable[]
image:https://badgen.net/github/release/joke/spock-mockable/stable[]
image:https://badgen.net/github/dependabot/joke/spock-mockable[]
image:https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg[link=https://conventionalcommits.org]
image:https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit[pre-commit, link=https://github.com/pre-commit/pre-commit]

`spock-mockable` allows creation of mocks otherwise un-mockable by the http://spockframework.org/[Spock Framework].

Spock is not capable of mocking `private` or `final` classes or methods
because they are not accessible via inheritance. `spock-mockable` uses JVM instrumentation to
modify these classes upon class loading and apply looser access restrictions.
In consequence Spock is capable of mocking these classes.

* Changes method visibility `private` to `protected`
* Removes `final` from classes and methods
* Automatically attaches java agent
* Redefines classes via https://bytebuddy.net/[Byte Buddy] transformation.
* Working with Spock Framework 2.0, 2.1, 2.2 and 2.3

== Gradle Dependency

image:https://badgen.net/github/release/joke/spock-mockable/stable[]

.build.gradle
[source,groovy]
----
dependencies {
    testImplementation 'io.github.joke:spock-mockable:x.y.z'
}
----

== Maven Dependency

.pom.xml
[source,xml]
----
<depenencies>
  <dependency>
    <groupId>io.github.joke</groupId>
    <artifactId>spock-mockable</artifactId>
    <version>x.y.z</version>
    <scope>test</scope>
  </dependency>
</depenencies>
----

== Usage

Under normal circumstances classes needing to undergo transformation are detected automatically.

.Mock definition
[source,groovy]
----
class MySpec extends Specification {
    // either
    Person person = Mock() // detected class based on type of variable
    // or
    def person = Mock(Person) // detected class based on Mock parameter
}
----

.Stub definition
[source,groovy]
----
class MySpec extends Specification {
    // either
    Person person = Stub() // detected class based on type of variable
    // or
    def person = Stub(Person) // detected class based on Mock parameter
}
----

.Spy definition
[source,groovy]
----
class MySpec extends Specification {
    // either
    def person = new Person()
    Person personSpy = Spy(person) // detected class based on type of variable

    // or
    Person person = new Person()
    def personSpy = Spy(personInstance) // detected class based on Mock parameter


    // WARNING!
    def person = new Person()
    def person2 = personInstance // person2 is dynamic typed and ...
    def personSpy = Spy(person2) // ... class type information is lost in this case!
}
----

In special cases you might want to manually specify additional classes or packages to undergo transformation. This need might arise if the exact class type can not be referenced in the specification. In this case you can specify arbitrary class or package names manually.

.Mockable annotation
[source,groovy]
----
@Mockable(className = 'some.package.MyFirstClass')
@Mockable(className = 'some.package.MySecondClass')
@Mockable(packageName = 'some.package')
class PersonSpec extends Specification {
}
----

More examples can be found in link:examples[].

== How does it work

All `@Mockable` annotations are scanned during groovy's compilation phase for classes and registered.
At the start of a test JVM these classes are transformed by the JVM instrumentation
regardless of the actual test class the annotation has been placed on. This might lead to unexpected behaviour.

=== Conditionally disable transformation

You can disable `spock-mockable` by setting the JVM system property `spock-mockable.disabled=true`.
